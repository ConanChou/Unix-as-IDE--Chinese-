编译
====

Unix 平台下有很多编译和解释代码的工具，它们用法各异。然而，但是概念上很多步骤是一样的。这里我将讨论用 GNU 编译器集里的 ``gcc`` 编译 C，并简要介绍用 ``perl`` 作为解释器。

GCC
---

`GCC <http://gcc.gnu.org/>`_ 是个非常成熟的 GPL 许可的编译器集。也许大家知道得最多的还是用它来编译 C 和 C++ 程序。它的免费以及它广泛的装载在 Unix 类似的系统上（例如 Linux 和 BSD）,使得它如此长久地流行。当然，现在还有一些更加现代化的使用 `LLVM <http://llvm.org/>`_ 架构的替代编译器，比如 `Clang <http://clang.llvm.org/>`_\。

最好别把 GNU 编译器集的前端二进制码当作是一组各自为政的完整的编译器，而是把它当作将一组离散的工具串联起来的驱动器，用以执行分析、编译和链接等步骤。这就意味着你既可以把 GCC 当作相对简单的命令行来把 C 源文件直接编译到可执行二进制，你也可以用它来检查和调试编译过程中的每个小步骤。

在这里我不会去讨论 ``make`` 文件，虽说对于任何多于一个文件的 C 项目必不可少。我们会在下一章有关创建和自动化工具的文章中讨论。

目标码的编译和汇编
------------------

你可以如此将 C 源码编译到目标码： ::
    
    $ gcc -c example.c -o example.o

假设这是个 C 程序代码没有问题，这将会在当前目录有下生成一个未链接的二进制目标文件 ``example.o``\，或者它会告诉你编译为何失败。你可以用 ``objdump`` 来检查它的汇编码0： ::
    
    $ objdump -D example.o

此外，你还可以用加 ``-S`` 参数来使得 ``gcc`` 输出适当的汇编码： ::
    
    $ gcc -c -S example.c -o example.s

当汇编码和程序源代码被一起打印出来的时候可以是很有用的，或者至少是很有趣的： ::
    
    $ gcc -c -g -Wa,-a,-ad example.c > example.lst

预处理器
--------

C 预处理器 ``cpp`` 是用来将头文件和宏定义加入到代码里的。一般来说它是 ``gcc`` 的一部分，但你也可以来直接调用它来查看它生成的 C 代码： ::
    
    $ cpp example.c

这将会打印出将要被编译的完整版代码，即包含了头文件并已实施了相关的宏。

目标码的连接
------------

一个或多个目标码可以像这样被连接成适当的二进制文件： ::
    
    $ gcc example.o -o example

在这个例子里，GCC 只是抽象化呼叫了 GNU 连接器 ``ld``\。以上的命令生成了一个可执行二进制文件 ``example``\。

编译、装配和链接
----------------

以上所有的步骤其实可以一步做完： ::
    
    $ gcc example.c -o example

这看起来简单了一些。但是，单个地编译目标码其实在实际的效率上有其过人之处，因为当重新编译的时候有些不必要的代码就不用再编译了。至于这一点，我会在下一篇文章中讨论。

包含和连接
----------

C 文件和头文件可以被显式地包含在编译命令里，即用参数 ``-I``\： ::
    
    $ gcc -I/usr/include/somelib.h example.c -o example

类似的，如果代码需要被动态地连接到一个已编译好的系统库，这些库通常在像 ``/lib`` 或 ``/usr/lib`` 的共有位置。假设是 ``ncurses``\，我们可以在命令里包含一个 ``-l`` 参数： ::
    
    $ gcc -lncurses example.c -o example

如果在你的编译中有很多必要的包含和连接，将其放进环境变量是很明智的： ::
    
    $ export CFLAGS=-I/usr/include/somelib.h
    $ export CLIBS=-lncurses
    $ gcc $CFLAGS $CLIBS example.c -o example

这种常见的步骤也是 ``Makefile`` 可以帮你省略的东西之一。

编译计划
--------

为了查看 ``gcc`` 都用那些命令干了些什么，你可以在编译命令里加上 ``-v`` 开关。这样它就会把它的编译计划从标准错误流里打印出来： ::
    
    $ gcc -v -c example.c -o example.o

如果你不想要编译器真正地去生产目标文件或者已连接的二进制文件。有时用 ``-###`` 更好（译者按：这个方法貌似在zsh下不能使用）： ::

    $ gcc -### -c example.c -o example.o

这有助于让你看到哪些步骤 ``gcc`` 帮你简化了。但同时，在一些特殊的情况下，你也可以用它来发现哪些是你不希望编译器帮你做的步骤却在编译时被执行了。


